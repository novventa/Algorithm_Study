import java.util.Scanner;

/**
 * @author jihye.byun 
 * BOJ 1789 수들의 합 실버5 수학
 * 
 * 문제
 * 서로 다른 N개의 자연수의 합이 S이다.
 * S를 알 때, 자연수 N의 최댓값은 얼마일까?
 * 
 * 조건
 * 자연수 S(1 ≤ S ≤ 4,294,967,295)
 * 
 * 풀이
 * 1. 최대한 많은 숫자를 사용해서 S를 만들자.
 * 1-1. 제일 작은 자연수인 1부터 2, 3, 4, ... 순서대로 사용하자.
 * 2. 숫자를 하나 사용할 때 마다 사용한 숫자 카운트를 늘려주자.
 * 3. 차례대로 수의 합을 계산하다가 S와 같아지면 그대로 멈추고,
 * 3-1. S보다 커지면 지금까지 더한 숫자 개수에서 하나를 빼준다.
 * 3-1-1. 최대한 많은 수를 사용해야 하니까 200을 만들어야 되는데 210이 된 경우, 10을 사용하지 않으면 된다.
 * 4. S의 범위가 42억이니, long형으로 만들어주자.
 */

public class P1789 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		long S = sc.nextLong(); // 숫자의 조합으로 만들어야 하는 숫자들의 합 S 입력받기
		
		int count = 0; // 몇 개의 숫자를 사용했는지 나타낼 카운트
		
		long sum = 0; // 현재까지 사용한 숫자들의 합을 저장할 변수
		int num = 0; // sum에 더해줄 숫자를 나타낼 변수 (1씩 증가)
		
		while (true) { // while문 안에서 조건에 걸려 break되기 전까지 무한 반복
			sum += ++num; // 새로운 숫자를 사용해서 숫자들의 합을 증가시키자
			// 이전에 사용한 자연수는 다시 사용할 수 없으니, 1 증가시켜서 사용하자
			count++; // 새로운 숫자를 사용했으니 카운트를 늘려주자
			
			// 숫자들의 합이 S가 됐다면, 현재 사용한 숫자의 개수가 최대값이니 그대로 멈추자
			if (sum == S) break; 
			
			// 숫자들의 합이 S를 초과했다면, 숫자를 너무 많이 사용한 상태이다.
			// 이 때, sum - S 의 값을 가지는 숫자 하나만 미사용 상태로 되돌려주면 된다
			// : 최대한 많은 숫자를 사용하는 것이 목표이기 때문에
			// 그러니 해당 값을 가지는 숫자 하나만 미사용상태로 돌려준다는 의미로 카운트를 1 감소시키고
			// 그럼 sum == S가 됐다는 의미이니 while문을 탈출하자
			else if (sum > S) {
				count--;
				break;
			}
				
			// 위의 두 조건에 걸리지 않았다면 아직 숫자들의 합이 S보다 작은 것이니
			// while문을 반복 실행해서 다음 숫자를 더하러 가자 
		}
		
		System.out.println(count); // 사용한 숫자의 개수 출력
	}

}
