import java.util.Arrays;
import java.util.Scanner;

/**
 * @author jihye.byun
 * BOJ 2485 가로수 실버4 수학
 * 
 * 문제
 * 직선 도로 한 편에 가로수가 임의의 간격으로 심어져 있다.
 * 가로수들이 모두 같은 간격이 되도록 가로수를 추가로 심자.
 * 가능한 한 적은 수의 가로수를 심자.
 * 가로수의 위치는 기준점으로 부터 떨어져 있는 거리로 표현되며, 가로수의 위치는 모두 양의 정수이다.
 * 심어져 있는 가로수의 위치가 주어질 때,
 * 모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소 수를 구하시오.
 * 추가되는 나무는 기존의 나무들 사이에만 심을 수 있다.
 * 
 * 조건
 * 이미 심어져 있는 가로수의 수를 나타내는 하나의 정수 N(3 ≤ N ≤ 100,000)
 * 가로수의 위치를 나타내는 정수는 1,000,000,000 이하
 * 가로수의 위치를 나타내는 정수는 모두 다르다.
 * 
 * 풀이
 * 0. 가로수의 위치가 기준점에서부터 순서대로 주어질까? sort하지 않아도 될까? => sort하지 않아도 된다!
 * 1. 가로수의 위치를 입력받으며, 두 번째 가로수 부터는 바로 전 가로수와의 거리 차이를 저장하자.
 * 2. 거리 차이를 저장한 gap 배열을 오름차순으로 정렬하자.
 * 3. gap 배열에서 가장 작은 값부터 시작해서 배열의 다음 값이 가장 작은 값의 배수인지 확인하자.
 * 4. 만약 배수가 아니라면, 두 수의 최대 공약수를 찾고 다음 값부터는 최대 공약수의 배수인지 확인하자.
 * 4-1. 최대공약수는 유클리드 알고리즘으로 구하자.
 * 5. 이렇게 gap 배열의 마지막 값까지 확인하며 마지막 최대 공약수를 찾아 minGap 변수에 저장해두자.
 * 6. gap 배열을 다시 처음부터 확인하며 각 값을 minGap으로 나눈 몫 - 1 이 그 gap을 가진 두 가로수 사이에 추가로 심어야 하는 가로수 개수이다.
 * 6-1. 이 말은 곧 gap 배열의 모든 값의 합을 minGap으로 나눈 몫 - (이미 심어져 있는 가로수의 개수 - 1)이 추가로 심어야 하는 가로수 개수라는 뜻이니,
 * 6-2. 처음 gap 배열을 돌 때 모든 값을 더해서 sumGap 변수에 저장해두자.
 * 
 * +구글링을 통해 발견한 보완점 : 입력받은 가로수의 위치 중 마지막 값 - 첫 번째 값 = sumGap이다.
 * +보완점2 : gap을 따로 저장할 필요 없이 초기 minGap을 0으로 선언하고, 가로수 위치를 입력받으며 (그 전 가로수와의 위치차이, minGap)으로 gcd실행
 */

public class P2485 {
	
	public static int gcd(int a, int b) {
		// a와 b의 최대공약수를 반환해주는 method
		
		// 유클리드 알고리즘
		// a > b 일 때,
		// a와 b의 최대 공약수는 b와 (a를 b로 나눈 나머지 r)의 최대공약수와 같다
		// 이 때, 나머지가 0이 아니라면 다시 큰 값인 b를 a에, 작은 값인 r을 b에 대입하여 위 과정을 반복한다.
		// 나머지가 0이 되었을 때 나누는 수(b에 대입되어 있던 수)가 a와 b의 최대공약수이다.
		
		// 재귀로 구현한 유클리드 알고리즘
		if (b == 0) return a; // 나머지가 0이 되면 그 때의 나누는 수가 최대공약수이다.
		return gcd(b, a % b); // 나머지가 0이 아니면 b와 a%b를 대입해서 재귀 호출한다.
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int treeCnt = sc.nextInt(); // 이미 심어져 있는 가로수의 수 입력받기
		int[] tree = new int[treeCnt]; // 이미 심어져 있는 가로수의 위치를 저장할 배열 공간
		int[] gap = new int[treeCnt - 1]; // 두 가로수 사이의 위치 차이를 저장할 배열 공간
		
		for (int idx = 0; idx < treeCnt; idx++) {
			tree[idx] = sc.nextInt(); // 이미 심어져 있는 가로수의 위치 입력받기
			
			if (idx == 0) continue; // 두 번째 가로수 부터
			
			gap[idx - 1] = tree[idx] - tree[idx - 1]; // 이전 가로수와의 위치 차이를 gap 배열에 저장하기
		}
		sc.close(); // 스캐너 닫기
		
		Arrays.sort(gap); // 위치 차이 배열을 오름차순으로 정렬하기
		
		int minGap = gap[0]; // 두 가로수 사이의 위치 차이 중 가장 작은 값을 최대 가로수 간격이라고 가정하자
		int sumGap = gap[0]; // 모든 가로수의 위치 차이 합을 저장할 변수
		
		for (int idx = 1; idx < treeCnt - 1; idx++) {
			sumGap += gap[idx]; // 현재 간격을 sumGap에 더해주자
			
			// 두 가로수 사이의 간격이 최대 간격으로 나누어 떨어지면 다음 간격을 확인하러 가자
			if (gap[idx] % minGap == 0) continue;
			
			// 두 가로수 사이의 간격이 최대 간격으로 나누어 떨어지지 않는다면
			// 현재 간격과 최대 간격의 최대공약수를 찾자
			minGap = gcd(gap[idx], minGap);
		}
		
		int result = sumGap / minGap - (treeCnt - 1); // 새로 심어야 하는 가로수의 수를 계산하자
		
		System.out.println(result); // 출력
	}
	
}

